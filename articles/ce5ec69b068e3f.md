---
title: 'Prisma バージョンアップの苦労'
emoji: '🔖'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['prisma']
published: false
---

# はじめに

この記事は「Medley（メドレー） Advent Calendar 2024」5 日目の記事です！

https://qiita.com/advent-calendar/2024/medley

こんにちは、メドレーの人材プラットフォーム本部でエンジニアをしている手嶋です。
私が開発を担当している[ジョブメドレーアカデミー](https://jm-academy.jp/)では ORM に Prisma を使っています。その Prisma のバージョンアップに取り組んだ時の試行錯誤したことや学びを共有したいと思います。

# Prisma とは

どういうライブラリなのか書く

# バージョンアップ時に気をつけること

今まで、本番コードで使用しているような主要なライブラリのバージョンアップをやった経験がなかったので、どのようなことに気をつけて実施すべきか調べることにしました。

Prisma は公式ドキュメントに [Upgrade guides](https://www.prisma.io/docs/orm/more/upgrade-guides) があり、バージョンアップ時の手順も記載されていて助かりました。
公式ドキュメントや、前回バージョンアップした PR、チームのメンバーにも助言をもらい、以下に注意して進めることにしました。

- リリースノートを読み、Breaking Change（破壊的変更）や、新しくリリースされた機能を確認する
- リリース直後のバージョンや、x.x.0 は新しいバグが発見される場合があるため、一つ前のバージョンにしておく
- `prisma` と `@prisma/client` どちらもバージョンを揃える必要がある

# 今回のバージョンアップで一番ハマったポイント

今回は 5.9.1（今年 2 月リリース）からのマイナーバージョンのアップデートだったのもあり、リリースノートを読む限りでは Breaking Change はありませんでした。しかし、いざバージョンを上げてテストを実行すると、日時が関わるテストの一部が失敗するようになりました。

## 起きた事象： `$queryRaw` で取得した Date 型の値に差が出た

Prisma の `$queryRaw` は生の SQL を実行する関数です。Date 型を値を取得する SQL を`$queryRaw`で実行すると、以下のように新旧バージョンで結果に差が出ました。

```typescript
const result = await prisma.$queryRaw`
  SELECT '2024-10-01 10:00:00'::timestamp
`;
console.log(result);

// 9時間マイナスされるようになった
旧バージョン: [ { timestamp: 2024-10-01T10:00:00.000Z } ]
新バージョン: [ { timestamp: 2024-10-01T01:00:00.000Z } ]
```

## 調査したこと

<!-- この 説明で伝わるのか？実際のコードとか詳細が必要だとすると、そのまま載せていいのか-->
<!-- 前提として、は段落分けた方がいい？ -->

前提として、Prisma で日時を保存すると、DB のタイムゾーン設定に関わらず、UTC 時間 に変換されて保存されてしまいます。そのためジョブメドレーアカデミーでは Prisma の middleware を作成して、DB に渡すデータ(where や data など)に Date 型のものが含まれていれば、それに対して 9 時間プラス、DB から出力されたデータに Date 型のものが含まれていれば、それに対して 9 時間マイナスするようにしています。

```TypeScript
import { PrismaClient } from '@prisma/client';
import { addHours, addMinutes, subHours, subMinutes } from 'date-fns';
import { clone } from 'ramda';

function getTimezoneOffset(): {
  hours: number;
  minutes: number;
} {
  const date = new Date();
  const offset = -date.getTimezoneOffset();
  return {
    hours: Math.floor(offset / 60),
    minutes: offset % 60,
  };
}

const offset = getTimezoneOffset();

function addTimezoneOffset(date: Date): Date {
  return addMinutes(addHours(date, offset.hours), offset.minutes);
}

function subtractTimezoneOffset(date: Date): Date {
  return subMinutes(subHours(date, offset.hours), offset.minutes);
}

function isPrimitive(value: unknown): boolean {
  return (
    (typeof value !== 'object' && typeof value !== 'function') || value === null
  );
}

function recursivelyTransformDateData(
  obj: Record<string, unknown>,
  transform: (date: Date) => Date,
): void {
  if (!obj) {
    return;
  }

  Object.keys(obj).forEach((key) => {
    const element = obj[key];
    if (element instanceof Date) {
      obj[key] = transform(element);
      return;
    }
    if (isPrimitive(element)) {
      return;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    recursivelyTransformDateData(element as any, transform);
  });
}

function absorbTimezoneDifference<T>(
  value: T,
  transform: (date: Date) => Date,
): T {
  if (value instanceof Date) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return transform(value) as any;
  }
  if (isPrimitive(value)) {
    return value;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  recursivelyTransformDateData(value as any, transform);
  return value;
}

// @see: https://github.com/medley-inc/academy/pull/258
export function applyAbsorbTimezoneDifferenceMiddleware(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  client: PrismaClient<any>,
): void {
  client.$use(async (params, next) => {
    params.args = absorbTimezoneDifference(
      clone(params.args),
      addTimezoneOffset,
    );

    const result = await next(params);

    return absorbTimezoneDifference(result, subtractTimezoneOffset);
  });
}
```

このため、middleware 内部の処理が新旧バージョンで変化しているかどうか調べるためにログを追加しました。

```TypeScript
export function applyAbsorbTimezoneDifferenceMiddleware(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  client: PrismaClient<any>,
): void {
  client.$use(async (params, next) => {
    console.log('absorbTimezoneDifferenceに渡す前のparams.args', params.args);
    params.args = absorbTimezoneDifference(
      clone(params.args),
      addTimezoneOffset,
    );
    console.log('absorbTimezoneDifferenceに渡した後のparams.args', params.args);
    const result = await next(params);
    console.log('next実行後', result);
    const result2 = absorbTimezoneDifference(result, subtractTimezoneOffset);
    console.log('next実行後absorbTimezoneDifferenceの結果', result2);
    return result2;
  });
}

```

- ミドルウェアがおかしいとアタリをつけて、調査したこと書く
  なんでミドルウェアが怪しいと思ったのかも書く

## 何が原因だったか

- 調査した結果、ここがこうなってたと書く
- queryRaw の結果は日付などを文字列で返してたが Date 型を返すようになりミドルウェアの Date 型の分岐に入るようになったから時差が補正されるようになった

## 対応したこと

プロダクションコードを変更するためにやったこと、動作確認とか
原因解決のために対応したこと
テスト追加した

# おわりに

紆余曲折ありましたが、無事 Prisma のバージョンアップができました。
今回ハマったポイントは Prisma のタイムゾーン問題を middleware で解消している場合にのみ起こる事象ですが、参考になれば嬉しいです！

明日は、・・・
